@page
@using Microsoft.AspNetCore.Authorization
@using BiketaBai.Helpers
@attribute [Authorize]
@model TrackRentersModel
@{
    ViewData["Title"] = "Track Renters";
}

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="~/css/premium-minimal.css" asp-append-version="true" />

<style>
    .bike-marker-icon {
        background: transparent !important;
        border: none !important;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
    }
    .bike-marker-icon svg {
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
    }
</style>

<div class="page-container">
    <div class="page-header">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--space-4);">
            <div>
                <h1 class="page-title">
                    <i class="bi bi-geo-alt-fill"></i> Track Active Renters
                </h1>
                <p class="page-subtitle">Monitor the location of renters with active bookings</p>
            </div>
            <a href="/Owner/MyBikes" class="btn-minimal btn-minimal-ghost">
                <i class="bi bi-arrow-left"></i> Back to My Bikes
            </a>
        </div>
    </div>

    @if (!Model.ActiveBookings.Any())
    {
        <div class="card-minimal">
            <div style="text-align: center; padding: var(--space-8);">
                <i class="bi bi-bicycle" style="font-size: 4rem; color: var(--neutral-300); margin-bottom: var(--space-4);"></i>
                <h3 style="color: var(--text-primary); margin-bottom: var(--space-2);">No Active Rentals</h3>
                <p style="color: var(--neutral-600);">You don't have any active rentals at the moment.</p>
            </div>
        </div>
    }
    else
    {
        <!-- Active Rentals List -->
        <div class="card-minimal mb-4">
            <div class="card-minimal-header">
                <h2 class="card-minimal-title">
                    <i class="bi bi-bicycle"></i> Active Rentals (@Model.ActiveBookings.Count)
                </h2>
            </div>
            <div class="grid-minimal">
                @foreach (var booking in Model.ActiveBookings)
                {
                    var latestLocation = Model.LatestLocations.GetValueOrDefault(booking.BookingId);
                    var hasLocation = latestLocation != null;
                    var isOverdue = TimeZoneHelper.ToPhilippineTime(booking.EndDate) < TimeZoneHelper.GetPhilippineTimeNow();
                    
                    <div class="card-minimal card-minimal-compact" data-booking-id="@booking.BookingId">
                        <div style="display: grid; grid-template-columns: 1fr auto; gap: var(--space-4); align-items: start;">
                            <div>
                                <h5 style="font-size: 1.125rem; font-weight: 700; margin-bottom: var(--space-2);">
                                    @booking.Bike.Brand @booking.Bike.Model
                                </h5>
                                <div style="display: flex; flex-direction: column; gap: var(--space-1); font-size: 0.875rem; color: var(--neutral-600);">
                                    <p style="margin: 0;">
                                        <i class="bi bi-person"></i> <strong>Renter:</strong> @booking.Renter.FullName
                                    </p>
                                    <p style="margin: 0;">
                                        <i class="bi bi-hash"></i> <strong>Quantity:</strong> @booking.Quantity bike(s)
                                    </p>
                                    <p style="margin: 0;">
                                        <i class="bi bi-calendar-x"></i> <strong>Return by:</strong> @TimeZoneHelper.FormatPhilippineTime(booking.EndDate)
                                    </p>
                                    <p style="margin: 0;">
                                        <i class="bi bi-clock"></i> <strong>Time remaining:</strong> 
                                        <span class="time-remaining" data-end-date="@TimeZoneHelper.FormatPhilippineTimeIso(booking.EndDate)">
                                            Calculating...
                                        </span>
                                    </p>
                                    @if (isOverdue)
                                    {
                                        <p style="margin: 0; color: var(--error); font-weight: 600;">
                                            <i class="bi bi-exclamation-triangle-fill"></i> OVERDUE
                                        </p>
                                    }
                                </div>
                                
                                @if (hasLocation)
                                {
                                    <div class="location-display" style="margin-top: var(--space-3); padding: var(--space-3); background: var(--sage-bg); border-radius: var(--radius-md);">
                                        <p style="margin: 0 0 var(--space-2) 0; font-weight: 600; color: var(--text-primary);">
                                            <i class="bi bi-geo-alt"></i> Current Location <span style="color: var(--success); font-size: 0.75rem;">‚óè Live</span>
                                        </p>
                                        <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                                            <strong>Coordinates:</strong> 
                                            <span style="font-family: monospace; color: var(--neutral-700);">
                                                @latestLocation.Latitude.ToString("F6"), @latestLocation.Longitude.ToString("F6")
                                            </span>
                                        </p>
                                        <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                                            <strong>Distance from store:</strong> 
                                            <span style="color: @(latestLocation.IsWithinGeofence ? "var(--success)" : "var(--error)"); font-weight: 600;">
                                                @latestLocation.DistanceFromStoreKm?.ToString("F2") km
                                            </span>
                                        </p>
                                        <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                                            <strong>Status:</strong> 
                                            @if (latestLocation.IsWithinGeofence)
                                            {
                                                <span style="color: var(--success); font-weight: 600;">
                                                    <i class="bi bi-check-circle"></i> Within Geofence
                                                </span>
                                            }
                                            else
                                            {
                                                <span style="color: var(--error); font-weight: 600;">
                                                    <i class="bi bi-exclamation-triangle"></i> Outside Geofence
                                                </span>
                                            }
                                        </p>
                                        <p style="margin: 0; font-size: 0.75rem; color: var(--neutral-500); margin-top: var(--space-1);">
                                            Last updated: @TimeZoneHelper.FormatPhilippineTime(latestLocation.TrackedAt)
                                        </p>
                                    </div>
                                }
                                else
                                {
                                    <div class="location-waiting" style="margin-top: var(--space-3); padding: var(--space-3); background: var(--neutral-100); border-radius: var(--radius-md);" data-booking-id="@booking.BookingId">
                                        <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                                            <i class="bi bi-info-circle"></i> Location tracking not available yet. The renter needs to start location tracking.
                                        </p>
                                        <p style="margin: 0; font-size: 0.75rem; color: var(--neutral-500); margin-top: var(--space-1);">
                                            <i class="bi bi-hourglass-split"></i> Waiting for location update...
                                        </p>
                                    </div>
                                }
                            </div>
                            <div style="display: flex; flex-direction: column; gap: var(--space-2);">
                                @if (hasLocation)
                                {
                                    <button type="button" 
                                            class="btn-minimal btn-minimal-primary btn-minimal-sm btn-view-location" 
                                            data-booking-id="@booking.BookingId"
                                            data-latitude="@latestLocation.Latitude"
                                            data-longitude="@latestLocation.Longitude"
                                            data-renter-name="@(booking.Renter.FullName)"
                                            data-bike-name="@($"{booking.Bike.Brand} {booking.Bike.Model}")"
                                            data-distance="@latestLocation.DistanceFromStoreKm"
                                            data-is-within="@latestLocation.IsWithinGeofence.ToString().ToLower()">
                                        <i class="bi bi-map"></i> View on Map
                                    </button>
                                }
                                else
                                {
                                    <button type="button" 
                                            class="btn-minimal btn-minimal-outline btn-minimal-sm btn-waiting-location" 
                                            data-booking-id="@booking.BookingId"
                                            disabled>
                                        <i class="bi bi-hourglass-split"></i> Waiting for Location
                                    </button>
                                }
                                @if (hasLocation)
                                {
                                    <a href="/Owner/TrackRenter/@booking.BookingId" class="btn-minimal btn-minimal-primary btn-minimal-sm">
                                        <i class="bi bi-map"></i> Track on Map
                                    </a>
                                }
                                <a href="/Bookings/Details/@booking.BookingId" class="btn-minimal btn-minimal-outline btn-minimal-sm">
                                    <i class="bi bi-eye"></i> View Details
                                </a>
                            </div>
                        </div>
                    </div>
                }
            </div>
        </div>

        <!-- Map Container -->
        <div class="card-minimal">
            <div class="card-minimal-header">
                <h2 class="card-minimal-title">
                    <i class="bi bi-map"></i> Location Map
                </h2>
            </div>
            <div style="padding: 0; border-radius: var(--radius-lg); overflow: hidden;">
                <div id="map" style="height: 500px; width: 100%;"></div>
            </div>
        </div>
    }
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.0/signalr.min.js"></script>
<script>
    // Function to create a pin marker with bike logo
    function createBikeIcon(color = '#3388ff') {
        // Create SVG pin marker with bike icon
        const svg = `
            <svg xmlns="http://www.w3.org/2000/svg" width="25" height="41" viewBox="0 0 25 41">
                <!-- Pin shadow -->
                <ellipse cx="12.5" cy="38.5" rx="5" ry="2" fill="rgba(0,0,0,0.2)"/>
                <!-- Pin shape -->
                <path d="M 12.5 0 C 5.6 0 0 5.6 0 12.5 C 0 19.4 12.5 41 12.5 41 C 12.5 41 25 19.4 25 12.5 C 25 5.6 19.4 0 12.5 0 Z" fill="${color}" stroke="#fff" stroke-width="1.5"/>
                <!-- Bike icon in center -->
                <g transform="translate(12.5, 12.5) scale(0.35)">
                    <!-- Bike wheels -->
                    <circle cx="-8" cy="3" r="5" fill="none" stroke="#fff" stroke-width="2"/>
                    <circle cx="8" cy="3" r="5" fill="none" stroke="#fff" stroke-width="2"/>
                    <!-- Bike frame -->
                    <path d="M -8 3 L -2 -4 L 0 0 L 2 -4 L 8 3" stroke="#fff" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
                    <!-- Handlebars -->
                    <path d="M 0 -4 L -2 -6 M 0 -4 L 2 -6" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
                </g>
            </svg>
        `;
        
        return L.divIcon({
            html: svg,
            className: 'bike-marker-icon',
            iconSize: [25, 41],
            iconAnchor: [12.5, 41],
            popupAnchor: [0, -41]
        });
    }

    let map;
    let markers = {};
    let storeMarker;
    let geofenceCircles = {};
    let locationData = {}; // Store location data for each booking
    let locationTrackingConnection = null; // Store connection reference to prevent duplicate listeners
    let locationTrackingInitialized = false; // Flag to prevent duplicate initialization
    let locationTrackingHandlersRegistered = false; // Flag to track if handlers are already registered

        // Initialize map
        document.addEventListener('DOMContentLoaded', function() {
        // Default center (Manila) or store location
        const storeLat = @(Model.StoreLatitude?.ToString("F6") ?? "14.5995");
        const storeLng = @(Model.StoreLongitude?.ToString("F6") ?? "120.9842");
        const initialZoom = @(Model.StoreLatitude.HasValue ? "13" : "13");
        
        map = L.map('map').setView([parseFloat(storeLat), parseFloat(storeLng)], parseInt(initialZoom));

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        // Add store marker and geofence circle if store location is available
        @if (Model.StoreLatitude.HasValue && Model.StoreLongitude.HasValue)
        {
            var radius = Model.GeofenceRadiusKm ?? 5.0m;
            <text>
            // Add store marker
            storeMarker = L.marker([@Model.StoreLatitude.Value.ToString("F6"), @Model.StoreLongitude.Value.ToString("F6")], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map).bindPopup('@(Model.StoreName ?? "Store Location")');

            // Add geofence circle
            const geofenceRadius = @radius * 1000; // Convert km to meters
            const geofenceCircle = L.circle([@Model.StoreLatitude.Value.ToString("F6"), @Model.StoreLongitude.Value.ToString("F6")], {
                color: '#87A96B',
                fillColor: '#E8F0E3',
                fillOpacity: 0.3,
                radius: geofenceRadius
            }).addTo(map);
            geofenceCircles['store'] = geofenceCircle;
            </text>
        }

        // Load all active bookings with locations
        @foreach (var booking in Model.ActiveBookings)
        {
            var latestLocation = Model.LatestLocations.GetValueOrDefault(booking.BookingId);
            if (latestLocation != null)
            {
                <text>
                locationData[@booking.BookingId] = {
                    latitude: @latestLocation.Latitude,
                    longitude: @latestLocation.Longitude,
                    renterName: '@booking.Renter.FullName',
                    bikeName: '@booking.Bike.Brand @booking.Bike.Model',
                    distance: @latestLocation.DistanceFromStoreKm,
                    isWithinGeofence: @latestLocation.IsWithinGeofence.ToString().ToLower(),
                    trackedAt: '@latestLocation.TrackedAt.ToString("yyyy-MM-ddTHH:mm:ss")'
                };
                addRenterMarker(@booking.BookingId, @latestLocation.Latitude, @latestLocation.Longitude, '@booking.Renter.FullName', '@booking.Bike.Brand @booking.Bike.Model', @latestLocation.DistanceFromStoreKm, @latestLocation.IsWithinGeofence.ToString().ToLower());
                </text>
            }
        }

        // Fit map to show all markers
        if (Object.keys(markers).length > 0 || storeMarker) {
            const bounds = L.latLngBounds([]);
            if (storeMarker) {
                bounds.extend(storeMarker.getLatLng());
            }
            Object.values(markers).forEach(m => bounds.extend(m.getLatLng()));
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }

        // Initialize SignalR connection for real-time location updates
        initializeLocationTrackingSignalR();
        
        // Set up click handlers for "View on Map" buttons using event delegation (safe from XSS)
        document.addEventListener('click', function(e) {
            const target = e.target.closest('.btn-view-location');
            if (target) {
                e.preventDefault();
                const bookingId = parseInt(target.getAttribute('data-booking-id'));
                const lat = parseFloat(target.getAttribute('data-latitude'));
                const lng = parseFloat(target.getAttribute('data-longitude'));
                const renterName = target.getAttribute('data-renter-name') || 'Unknown';
                const bikeName = target.getAttribute('data-bike-name') || 'Unknown';
                const distance = parseFloat(target.getAttribute('data-distance') || 0);
                const isWithin = target.getAttribute('data-is-within') === 'true';
                
                showLocationOnMap(bookingId, lat, lng, renterName, bikeName, distance, isWithin);
            }
        });
    });

    function initializeLocationTrackingSignalR() {
        if (typeof signalR === 'undefined') {
            console.error('SignalR library not loaded. Retrying in 2 seconds...');
            setTimeout(initializeLocationTrackingSignalR, 2000);
            return;
        }
        
        // Prevent duplicate initialization if already initialized and connection exists
        if (locationTrackingInitialized && locationTrackingConnection && locationTrackingHandlersRegistered) {
            console.log('Location tracking SignalR already initialized with handlers, skipping...');
            return;
        }
        
        console.log('Initializing SignalR connection for location tracking...');
        
        // Check if notification hub connection already exists from _Layout.cshtml
        // First check global scope, then check local variable
        let connection;
        let isReusingConnection = false;
        
        // Check global scope first (persistent across pages)
        if (typeof window.BiketaBaiNotifications !== 'undefined' && 
            window.BiketaBaiNotifications.connection) {
            console.log('Reusing existing notification hub connection from global scope for location tracking');
            connection = window.BiketaBaiNotifications.connection;
            isReusingConnection = true;
        } else if (typeof notificationHubConnection !== 'undefined' && notificationHubConnection) {
            console.log('Reusing existing notification hub connection for location tracking');
            connection = notificationHubConnection;
            isReusingConnection = true;
        } else {
            // Create a new connection if one doesn't exist
            console.log('Creating new SignalR connection for location tracking');
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/notificationHub")
                .withAutomaticReconnect({
                    nextRetryDelayInMilliseconds: retryContext => {
                        if (retryContext.elapsedMilliseconds < 2000) return 0;
                        if (retryContext.elapsedMilliseconds < 10000) return 2000;
                        if (retryContext.elapsedMilliseconds < 30000) return 10000;
                        return 30000;
                    }
                })
                .build();
        }
        
        // Store connection reference
        locationTrackingConnection = connection;
        
        // Remove existing handlers if they were already registered (prevents duplicates on retry)
        if (locationTrackingHandlersRegistered || isReusingConnection) {
            console.log('Removing existing location tracking handlers to prevent duplicates...');
            try {
                connection.off("ReceiveLocationUpdate");
            } catch (e) {
                console.warn('Could not remove existing handlers (this is OK if handlers were not registered):', e);
            }
            locationTrackingHandlersRegistered = false;
        }

        // Listen for location updates (register handler)
        connection.on("ReceiveLocationUpdate", function(data) {
            console.log("üìç Received location update:", data);
            
            if (!data || !data.bookingId) {
                console.error("‚ùå Invalid location update data:", data);
                return;
            }
            
            const bookingId = parseInt(data.bookingId);
            const lat = parseFloat(data.latitude);
            const lng = parseFloat(data.longitude);
            const distance = parseFloat(data.distanceKm || 0);
            const isWithin = data.isWithinGeofence === true || data.isWithinGeofence === 'true';
            const renterName = data.renterName || 'Unknown';
            const bikeName = data.bikeName || 'Unknown';
            const trackedAt = data.trackedAt || new Date().toISOString();
            
            // Validate coordinates
            if (isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) {
                console.error("‚ùå Invalid coordinates in location update:", data);
                return;
            }
            
            console.log(`‚úÖ Processing location update for booking ${bookingId}: ${lat}, ${lng}`);
            
            // Update location data
            locationData[bookingId] = {
                latitude: lat,
                longitude: lng,
                renterName: renterName,
                bikeName: bikeName,
                distance: distance,
                isWithinGeofence: isWithin,
                trackedAt: trackedAt
            };

            // Update marker on map - always update to show movement
            console.log(`üîÑ Calling updateRenterMarker for booking ${bookingId}`);
            updateRenterMarker(
                bookingId,
                lat,
                lng,
                renterName,
                bikeName,
                distance,
                isWithin
            );
            console.log(`‚úÖ updateRenterMarker completed for booking ${bookingId}`);

            // Update location display in the booking card (with coordinates)
            console.log(`üîÑ Updating location display for booking ${bookingId}...`);
            updateLocationDisplay(bookingId, lat, lng, distance, isWithin, trackedAt);
            
            // Update "View on Map" button data attributes
            const bookingCard = document.querySelector(`[data-booking-id="${bookingId}"]`);
            if (bookingCard) {
                console.log(`‚úÖ Found booking card for booking ${bookingId}`);
                const viewButton = bookingCard.querySelector('button.btn-view-location');
                if (viewButton) {
                    viewButton.setAttribute('data-latitude', lat.toString());
                    viewButton.setAttribute('data-longitude', lng.toString());
                    viewButton.setAttribute('data-distance', distance.toString());
                    viewButton.setAttribute('data-is-within', isWithin.toString());
                    console.log(`‚úÖ Updated view button for booking ${bookingId}`);
                } else {
                    console.warn(`‚ö†Ô∏è View button not found for booking ${bookingId}`);
                }
            } else {
                console.warn(`‚ö†Ô∏è Booking card not found for booking ${bookingId}`);
            }
        });
        
        // Mark handlers as registered and initialization as complete
        locationTrackingHandlersRegistered = true;
        locationTrackingInitialized = true;

        // Only start connection if it's a new connection (not reused from _Layout)
        // Check connection state - if it's already connected, we can just add listeners
        if (connection.state === signalR.HubConnectionState.Disconnected) {
            connection.start()
                .then(function() {
                    console.log("Location tracking SignalR connected. Listening for location updates...");
                })
                .catch(function(err) {
                    console.error("Location tracking SignalR connection error:", err);
                    // Reset flags on error so it can be retried
                    locationTrackingHandlersRegistered = false;
                    locationTrackingInitialized = false;
                    locationTrackingConnection = null;
                    // Retry connection after 5 seconds
                    setTimeout(function() {
                        console.log("Retrying location tracking SignalR connection...");
                        initializeLocationTrackingSignalR();
                    }, 5000);
                });
        } else {
            console.log("Location tracking SignalR already connected. Listening for location updates...");
        }

        // Handle connection state changes (only register once)
        connection.onreconnecting(function() {
            console.log("Location tracking SignalR reconnecting...");
        });

        connection.onreconnected(function() {
            console.log("Location tracking SignalR reconnected");
        });

        connection.onclose(function() {
            console.log("Location tracking SignalR connection closed");
            // Reset flags on close so it can be reinitialized if needed
            locationTrackingInitialized = false;
            locationTrackingConnection = null;
            locationTrackingHandlersRegistered = false;
        });
    }

    function updateLocationDisplay(bookingId, latitude, longitude, distance, isWithinGeofence, trackedAt) {
        console.log(`üîÑ updateLocationDisplay called for booking ${bookingId} with coords: ${latitude}, ${longitude}`);
        
        const bookingCard = document.querySelector(`[data-booking-id="${bookingId}"]`);
        if (!bookingCard) {
            console.warn(`‚ö†Ô∏è Booking card not found for booking ID: ${bookingId}`);
            console.warn('Available booking cards:', Array.from(document.querySelectorAll('[data-booking-id]')).map(el => el.getAttribute('data-booking-id')));
            return;
        }
        
        console.log(`‚úÖ Found booking card for booking ${bookingId}`);

        // Find or create location display section
        let locationSection = bookingCard.querySelector('.location-display');
        if (!locationSection) {
            // Remove the "waiting for location" message if it exists
            const waitingDiv = bookingCard.querySelector('.location-waiting');
            if (waitingDiv) {
                console.log(`‚úÖ Removing waiting message for booking ${bookingId}`);
                waitingDiv.remove();
            }
            
            // Also try to find by style attribute (fallback)
            const waitingDivByStyle = bookingCard.querySelector('div[style*="background: var(--neutral-100)"]');
            if (waitingDivByStyle && waitingDivByStyle.textContent.includes('Location tracking not available')) {
                console.log(`‚úÖ Removing waiting message (by style) for booking ${bookingId}`);
                waitingDivByStyle.remove();
            }
            
            // Find the card content - try multiple selectors
            let cardContent = bookingCard.querySelector('div > div:first-child');
            if (!cardContent) {
                // Try alternative selector
                cardContent = bookingCard.querySelector('.card-minimal-body') || bookingCard.querySelector('div:first-child > div:first-child');
            }
            
            if (cardContent) {
                locationSection = document.createElement('div');
                locationSection.className = 'location-display';
                locationSection.style.cssText = 'margin-top: var(--space-3); padding: var(--space-3); background: var(--sage-subtle); border-radius: var(--radius-md);';
                cardContent.appendChild(locationSection);
                console.log(`‚úÖ Created location display section for booking ${bookingId}`);
            } else {
                console.warn(`‚ö†Ô∏è Card content not found for booking ID: ${bookingId}`);
                console.warn('Booking card structure:', bookingCard);
                return;
            }
        }
        
        // Enable the "View on Map" button
        const viewButton = bookingCard.querySelector('button.btn-view-location');
        if (!viewButton) {
            // Find the disabled/waiting button and replace it
            const disabledButton = bookingCard.querySelector('button.btn-waiting-location') || 
                                   bookingCard.querySelector('button[disabled]');
            if (disabledButton) {
                console.log(`‚úÖ Found waiting button for booking ${bookingId}, enabling it...`);
                disabledButton.disabled = false;
                disabledButton.className = 'btn-minimal btn-minimal-primary btn-minimal-sm btn-view-location';
                disabledButton.innerHTML = '<i class="bi bi-map"></i> View on Map';
                // Get location data to set data attributes (safe from XSS)
                const locData = locationData[bookingId];
                if (locData) {
                    disabledButton.setAttribute('data-booking-id', bookingId.toString());
                    disabledButton.setAttribute('data-latitude', locData.latitude.toString());
                    disabledButton.setAttribute('data-longitude', locData.longitude.toString());
                    disabledButton.setAttribute('data-renter-name', locData.renterName || 'Unknown');
                    disabledButton.setAttribute('data-bike-name', locData.bikeName || 'Unknown');
                    disabledButton.setAttribute('data-distance', locData.distance.toString());
                    disabledButton.setAttribute('data-is-within', locData.isWithinGeofence.toString());
                    console.log(`‚úÖ Updated button attributes for booking ${bookingId}`);
                }
            } else {
                console.warn(`‚ö†Ô∏è No waiting button found for booking ${bookingId}`);
            }
        } else {
            console.log(`‚úÖ View button already exists for booking ${bookingId}`);
        }

        // Update location display
        let phTime;
        try {
            phTime = new Date(trackedAt).toLocaleString('en-US', {
                timeZone: 'Asia/Manila',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        } catch (e) {
            phTime = new Date().toLocaleString('en-US', {
                timeZone: 'Asia/Manila',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        const distanceValue = typeof distance === 'number' ? distance : parseFloat(distance || 0);
        const isWithin = isWithinGeofence === true || isWithinGeofence === 'true';

        const lat = typeof latitude === 'number' ? latitude : parseFloat(latitude || 0);
        const lng = typeof longitude === 'number' ? longitude : parseFloat(longitude || 0);

        locationSection.innerHTML = `
            <p style="margin: 0 0 var(--space-2) 0; font-weight: 600; color: var(--neutral-900);">
                <i class="bi bi-geo-alt"></i> Current Location <span style="color: var(--success); font-size: 0.75rem;">‚óè Live</span>
            </p>
            <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                <strong>Coordinates:</strong> 
                <span style="font-family: monospace; color: var(--neutral-700);">
                    ${lat.toFixed(6)}, ${lng.toFixed(6)}
                </span>
            </p>
            <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                <strong>Distance from store:</strong> 
                <span style="color: ${isWithin ? 'var(--success)' : 'var(--error)'}; font-weight: 600;">
                    ${distanceValue.toFixed(2)} km
                </span>
            </p>
            <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                <strong>Status:</strong> 
                ${isWithin 
                    ? '<span style="color: var(--success); font-weight: 600;"><i class="bi bi-check-circle"></i> Within Geofence</span>'
                    : '<span style="color: var(--error); font-weight: 600;"><i class="bi bi-exclamation-triangle"></i> Outside Geofence</span>'
                }
            </p>
            <p style="margin: 0; font-size: 0.75rem; color: var(--neutral-500); margin-top: var(--space-1);">
                Last updated: ${phTime}
            </p>
        `;
    }

    function addRenterMarker(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence) {
        updateRenterMarker(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence);
    }

    function updateRenterMarker(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence) {
        console.log(`üó∫Ô∏è Updating marker for booking ${bookingId} to: ${lat}, ${lng}`);
        
        const existingMarker = markers[bookingId];
        const isNewMarker = !existingMarker;

        // Create bike icon marker with color based on geofence status
        const markerIcon = createBikeIcon(isWithinGeofence ? '#3388ff' : '#ff3333');

        let marker;
        if (isNewMarker) {
            // Create new marker
            marker = L.marker([lat, lng], { 
            icon: markerIcon,
                title: `${renterName} - ${bikeName}`,
                zIndexOffset: 1000 // Ensure renter markers are on top
        })
        .addTo(map)
        .bindPopup(`
                <div style="min-width: 200px;">
                    <strong style="font-size: 1.1em;">${renterName}</strong><br>
                    <span style="color: #666;">${bikeName}</span><br>
                    <hr style="margin: 8px 0;">
                    <strong>Distance:</strong> ${distance.toFixed(2)} km<br>
                    <strong>Status:</strong> ${isWithinGeofence ? '<span style="color: green;">‚úì Within Geofence</span>' : '<span style="color: red;">‚ö† Outside Geofence</span>'}<br>
                    <strong>Coordinates:</strong><br>
                    <code style="font-size: 0.85em;">${lat.toFixed(6)}, ${lng.toFixed(6)}</code><br>
                    <small style="color: #666; display: block; margin-top: 8px;">
                        <i class="bi bi-circle-fill" style="color: #28a745; font-size: 0.6em;"></i> Live Tracking<br>
                        Updated: ${new Date().toLocaleTimeString()}
                    </small>
                </div>
        `);
        markers[bookingId] = marker;
        } else {
            // Update existing marker - ALWAYS update position
            marker = existingMarker;
            const currentPos = marker.getLatLng();
            
            console.log(`üìç Current marker position: ${currentPos.lat}, ${currentPos.lng}`);
            console.log(`üìç New position: ${lat}, ${lng}`);
            
            // Always update position (even if small change) to ensure movement is visible
            marker.setLatLng([lat, lng], {
                animate: true,
                duration: 0.8, // Smooth animation
                easeLinearity: 0.25
            });
            
            console.log(`‚úÖ Marker position updated to: ${lat}, ${lng}`);
            
            // Always update popup with new info
            marker.setPopupContent(`
                <div style="min-width: 200px;">
                    <strong style="font-size: 1.1em;">${renterName}</strong><br>
                    <span style="color: #666;">${bikeName}</span><br>
                    <hr style="margin: 8px 0;">
                    <strong>Distance:</strong> ${distance.toFixed(2)} km<br>
                    <strong>Status:</strong> ${isWithinGeofence ? '<span style="color: green;">‚úì Within Geofence</span>' : '<span style="color: red;">‚ö† Outside Geofence</span>'}<br>
                    <strong>Coordinates:</strong><br>
                    <code style="font-size: 0.85em;">${lat.toFixed(6)}, ${lng.toFixed(6)}</code><br>
                    <small style="color: #666; display: block; margin-top: 8px;">
                        <i class="bi bi-circle-fill" style="color: #28a745; font-size: 0.6em;"></i> Live Tracking<br>
                        Updated: ${new Date().toLocaleTimeString()}
                    </small>
                </div>
            `);
            
            // Update bike icon based on geofence status (always update to ensure correct color)
            marker.setIcon(createBikeIcon(isWithinGeofence ? '#3388ff' : '#ff3333'));
            console.log(`üîÑ Updated bike icon (${isWithinGeofence ? 'blue' : 'red'})`);
        }

        // Remove pulsing circle if it exists (no longer using pulsing animation)
        if (marker.pulseCircle) {
            map.removeLayer(marker.pulseCircle);
            marker.pulseCircle = null;
        }
        
        if (marker.pulseInterval) {
            clearInterval(marker.pulseInterval);
            marker.pulseInterval = null;
        }

        // Fit map to show all markers (only if new marker)
        if (isNewMarker && Object.keys(markers).length > 0) {
            const bounds = L.latLngBounds(Object.values(markers).map(m => m.getLatLng()));
            map.fitBounds(bounds, { padding: [50, 50] });
        }
    }

    function showLocationOnMap(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence) {
        // Add or update marker
        addRenterMarker(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence);

        // Center map on this location
        map.setView([lat, lng], 15);

        // Open popup
        if (markers[bookingId]) {
            markers[bookingId].openPopup();
        }
    }

    // Time remaining countdown
    function getPhilippineTime() {
        const now = new Date();
        const phTimeStr = now.toLocaleString('en-US', { 
            timeZone: 'Asia/Manila',
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: false
        });
        const parts = phTimeStr.split(', ');
        const dateParts = parts[0].split('/');
        const timeParts = parts[1].split(':');
        return new Date(
            parseInt(dateParts[2]), parseInt(dateParts[0]) - 1, parseInt(dateParts[1]),
            parseInt(timeParts[0]), parseInt(timeParts[1]), parseInt(timeParts[2])
        );
    }

    function updateTimeRemaining() {
        document.querySelectorAll('.time-remaining').forEach(function(element) {
            const endDateStr = element.getAttribute('data-end-date');
            if (!endDateStr) return;
            
            const endDateParts = endDateStr.split('T');
            const dateParts = endDateParts[0].split('-');
            const timeParts = endDateParts[1].split(':');
            
            const endDate = new Date(
                parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                parseInt(timeParts[0]), parseInt(timeParts[1]), parseInt(timeParts[2])
            );
            
            const nowPhilippine = getPhilippineTime();
            const diff = endDate.getTime() - nowPhilippine.getTime();
            
            if (diff <= 0) {
                element.textContent = 'OVERDUE';
                element.style.color = 'var(--error)';
            } else {
                const totalSeconds = Math.floor(diff / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                if (hours > 0) {
                    element.textContent = `${hours}h ${minutes}m remaining`;
                } else if (minutes > 0) {
                    element.textContent = `${minutes}m ${seconds}s remaining`;
                } else {
                    element.textContent = `${seconds}s remaining`;
                }
            }
        });
    }

    updateTimeRemaining();
    setInterval(updateTimeRemaining, 1000);
</script>

