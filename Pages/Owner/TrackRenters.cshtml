@page
@using Microsoft.AspNetCore.Authorization
@using BiketaBai.Helpers
@attribute [Authorize]
@model TrackRentersModel
@{
    ViewData["Title"] = "Track Renters";
}

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="~/css/premium-minimal.css" asp-append-version="true" />

<div class="page-container">
    <div class="page-header">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--space-4);">
            <div>
                <h1 class="page-title">
                    <i class="bi bi-geo-alt-fill"></i> Track Active Renters
                </h1>
                <p class="page-subtitle">Monitor the location of renters with active bookings</p>
            </div>
            <a href="/Owner/MyBikes" class="btn-minimal btn-minimal-ghost">
                <i class="bi bi-arrow-left"></i> Back to My Bikes
            </a>
        </div>
    </div>

    @if (!Model.ActiveBookings.Any())
    {
        <div class="card-minimal">
            <div style="text-align: center; padding: var(--space-8);">
                <i class="bi bi-bicycle" style="font-size: 4rem; color: var(--neutral-300); margin-bottom: var(--space-4);"></i>
                <h3 style="color: var(--text-primary); margin-bottom: var(--space-2);">No Active Rentals</h3>
                <p style="color: var(--neutral-600);">You don't have any active rentals at the moment.</p>
            </div>
        </div>
    }
    else
    {
        <!-- Active Rentals List -->
        <div class="card-minimal mb-4">
            <div class="card-minimal-header">
                <h2 class="card-minimal-title">
                    <i class="bi bi-bicycle"></i> Active Rentals (@Model.ActiveBookings.Count)
                </h2>
            </div>
            <div class="grid-minimal">
                @foreach (var booking in Model.ActiveBookings)
                {
                    var latestLocation = Model.LatestLocations.GetValueOrDefault(booking.BookingId);
                    var hasLocation = latestLocation != null;
                    var isOverdue = TimeZoneHelper.ToPhilippineTime(booking.EndDate) < TimeZoneHelper.GetPhilippineTimeNow();
                    
                    <div class="card-minimal card-minimal-compact" data-booking-id="@booking.BookingId">
                        <div style="display: grid; grid-template-columns: 1fr auto; gap: var(--space-4); align-items: start;">
                            <div>
                                <h5 style="font-size: 1.125rem; font-weight: 700; margin-bottom: var(--space-2);">
                                    @booking.Bike.Brand @booking.Bike.Model
                                </h5>
                                <div style="display: flex; flex-direction: column; gap: var(--space-1); font-size: 0.875rem; color: var(--neutral-600);">
                                    <p style="margin: 0;">
                                        <i class="bi bi-person"></i> <strong>Renter:</strong> @booking.Renter.FullName
                                    </p>
                                    <p style="margin: 0;">
                                        <i class="bi bi-hash"></i> <strong>Quantity:</strong> @booking.Quantity bike(s)
                                    </p>
                                    <p style="margin: 0;">
                                        <i class="bi bi-calendar-x"></i> <strong>Return by:</strong> @TimeZoneHelper.FormatPhilippineTime(booking.EndDate)
                                    </p>
                                    <p style="margin: 0;">
                                        <i class="bi bi-clock"></i> <strong>Time remaining:</strong> 
                                        <span class="time-remaining" data-end-date="@TimeZoneHelper.FormatPhilippineTimeIso(booking.EndDate)">
                                            Calculating...
                                        </span>
                                    </p>
                                    @if (isOverdue)
                                    {
                                        <p style="margin: 0; color: var(--error); font-weight: 600;">
                                            <i class="bi bi-exclamation-triangle-fill"></i> OVERDUE
                                        </p>
                                    }
                                </div>
                                
                                @if (hasLocation)
                                {
                                    <div class="location-display" style="margin-top: var(--space-3); padding: var(--space-3); background: var(--sage-bg); border-radius: var(--radius-md);">
                                        <p style="margin: 0 0 var(--space-2) 0; font-weight: 600; color: var(--text-primary);">
                                            <i class="bi bi-geo-alt"></i> Current Location <span style="color: var(--success); font-size: 0.75rem;">● Live</span>
                                        </p>
                                        <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                                            <strong>Distance from store:</strong> 
                                            <span style="color: @(latestLocation.IsWithinGeofence ? "var(--success)" : "var(--error)"); font-weight: 600;">
                                                @latestLocation.DistanceFromStoreKm?.ToString("F2") km
                                            </span>
                                        </p>
                                        <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                                            <strong>Status:</strong> 
                                            @if (latestLocation.IsWithinGeofence)
                                            {
                                                <span style="color: var(--success); font-weight: 600;">
                                                    <i class="bi bi-check-circle"></i> Within Geofence
                                                </span>
                                            }
                                            else
                                            {
                                                <span style="color: var(--error); font-weight: 600;">
                                                    <i class="bi bi-exclamation-triangle"></i> Outside Geofence
                                                </span>
                                            }
                                        </p>
                                        <p style="margin: 0; font-size: 0.75rem; color: var(--neutral-500); margin-top: var(--space-1);">
                                            Last updated: @TimeZoneHelper.FormatPhilippineTime(latestLocation.TrackedAt)
                                        </p>
                                    </div>
                                }
                                else
                                {
                                    <div style="margin-top: var(--space-3); padding: var(--space-3); background: var(--neutral-100); border-radius: var(--radius-md);">
                                        <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                                            <i class="bi bi-info-circle"></i> Location tracking not available yet. The renter needs to start location tracking.
                                        </p>
                                    </div>
                                }
                            </div>
                            <div style="display: flex; flex-direction: column; gap: var(--space-2);">
                                @if (hasLocation)
                                {
                                    <button type="button" 
                                            class="btn-minimal btn-minimal-primary btn-minimal-sm btn-view-location" 
                                            data-booking-id="@booking.BookingId"
                                            data-latitude="@latestLocation.Latitude"
                                            data-longitude="@latestLocation.Longitude"
                                            data-renter-name="@(booking.Renter.FullName)"
                                            data-bike-name="@($"{booking.Bike.Brand} {booking.Bike.Model}")"
                                            data-distance="@latestLocation.DistanceFromStoreKm"
                                            data-is-within="@latestLocation.IsWithinGeofence.ToString().ToLower()">
                                        <i class="bi bi-map"></i> View on Map
                                    </button>
                                }
                                else
                                {
                                    <button type="button" 
                                            class="btn-minimal btn-minimal-outline btn-minimal-sm" 
                                            disabled>
                                        <i class="bi bi-hourglass-split"></i> Waiting for Location
                                    </button>
                                }
                                <a href="/Bookings/Details/@booking.BookingId" class="btn-minimal btn-minimal-outline btn-minimal-sm">
                                    <i class="bi bi-eye"></i> View Details
                                </a>
                            </div>
                        </div>
                    </div>
                }
            </div>
        </div>

        <!-- Map Container -->
        <div class="card-minimal">
            <div class="card-minimal-header">
                <h2 class="card-minimal-title">
                    <i class="bi bi-map"></i> Location Map
                </h2>
            </div>
            <div style="padding: 0; border-radius: var(--radius-lg); overflow: hidden;">
                <div id="map" style="height: 500px; width: 100%;"></div>
            </div>
        </div>
    }
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.0/signalr.min.js"></script>
<script>
    let map;
    let markers = {};
    let storeMarker;
    let geofenceCircles = {};
    let locationData = {}; // Store location data for each booking
    let locationTrackingConnection = null; // Store connection reference to prevent duplicate listeners
    let locationTrackingInitialized = false; // Flag to prevent duplicate initialization
    let locationTrackingHandlersRegistered = false; // Flag to track if handlers are already registered

        // Initialize map
        document.addEventListener('DOMContentLoaded', function() {
        // Default center (Manila) or store location
        const storeLat = @(Model.StoreLatitude?.ToString("F6") ?? "14.5995");
        const storeLng = @(Model.StoreLongitude?.ToString("F6") ?? "120.9842");
        const initialZoom = @(Model.StoreLatitude.HasValue ? "13" : "13");
        
        map = L.map('map').setView([parseFloat(storeLat), parseFloat(storeLng)], parseInt(initialZoom));

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        // Add store marker and geofence circle if store location is available
        @if (Model.StoreLatitude.HasValue && Model.StoreLongitude.HasValue)
        {
            var radius = Model.GeofenceRadiusKm ?? 5.0m;
            <text>
            // Add store marker
            storeMarker = L.marker([@Model.StoreLatitude.Value.ToString("F6"), @Model.StoreLongitude.Value.ToString("F6")], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map).bindPopup('@(Model.StoreName ?? "Store Location")');

            // Add geofence circle
            const geofenceRadius = @radius * 1000; // Convert km to meters
            const geofenceCircle = L.circle([@Model.StoreLatitude.Value.ToString("F6"), @Model.StoreLongitude.Value.ToString("F6")], {
                color: '#87A96B',
                fillColor: '#E8F0E3',
                fillOpacity: 0.3,
                radius: geofenceRadius
            }).addTo(map);
            geofenceCircles['store'] = geofenceCircle;
            </text>
        }

        // Load all active bookings with locations
        @foreach (var booking in Model.ActiveBookings)
        {
            var latestLocation = Model.LatestLocations.GetValueOrDefault(booking.BookingId);
            if (latestLocation != null)
            {
                <text>
                locationData[@booking.BookingId] = {
                    latitude: @latestLocation.Latitude,
                    longitude: @latestLocation.Longitude,
                    renterName: '@booking.Renter.FullName',
                    bikeName: '@booking.Bike.Brand @booking.Bike.Model',
                    distance: @latestLocation.DistanceFromStoreKm,
                    isWithinGeofence: @latestLocation.IsWithinGeofence.ToString().ToLower(),
                    trackedAt: '@latestLocation.TrackedAt.ToString("yyyy-MM-ddTHH:mm:ss")'
                };
                addRenterMarker(@booking.BookingId, @latestLocation.Latitude, @latestLocation.Longitude, '@booking.Renter.FullName', '@booking.Bike.Brand @booking.Bike.Model', @latestLocation.DistanceFromStoreKm, @latestLocation.IsWithinGeofence.ToString().ToLower());
                </text>
            }
        }

        // Fit map to show all markers
        if (Object.keys(markers).length > 0 || storeMarker) {
            const bounds = L.latLngBounds([]);
            if (storeMarker) {
                bounds.extend(storeMarker.getLatLng());
            }
            Object.values(markers).forEach(m => bounds.extend(m.getLatLng()));
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [50, 50] });
            }
        }

        // Initialize SignalR connection for real-time location updates
        initializeLocationTrackingSignalR();
        
        // Set up click handlers for "View on Map" buttons using event delegation (safe from XSS)
        document.addEventListener('click', function(e) {
            const target = e.target.closest('.btn-view-location');
            if (target) {
                e.preventDefault();
                const bookingId = parseInt(target.getAttribute('data-booking-id'));
                const lat = parseFloat(target.getAttribute('data-latitude'));
                const lng = parseFloat(target.getAttribute('data-longitude'));
                const renterName = target.getAttribute('data-renter-name') || 'Unknown';
                const bikeName = target.getAttribute('data-bike-name') || 'Unknown';
                const distance = parseFloat(target.getAttribute('data-distance') || 0);
                const isWithin = target.getAttribute('data-is-within') === 'true';
                
                showLocationOnMap(bookingId, lat, lng, renterName, bikeName, distance, isWithin);
            }
        });
    });

    function initializeLocationTrackingSignalR() {
        if (typeof signalR === 'undefined') {
            console.error('SignalR library not loaded. Retrying in 2 seconds...');
            setTimeout(initializeLocationTrackingSignalR, 2000);
            return;
        }
        
        // Prevent duplicate initialization if already initialized and connection exists
        if (locationTrackingInitialized && locationTrackingConnection && locationTrackingHandlersRegistered) {
            console.log('Location tracking SignalR already initialized with handlers, skipping...');
            return;
        }
        
        console.log('Initializing SignalR connection for location tracking...');
        
        // Check if notification hub connection already exists from _Layout.cshtml
        // If it does, reuse it; otherwise create a new connection
        let connection;
        let isReusingConnection = false;
        if (typeof notificationHubConnection !== 'undefined' && notificationHubConnection) {
            console.log('Reusing existing notification hub connection for location tracking');
            connection = notificationHubConnection;
            isReusingConnection = true;
        } else {
            // Create a new connection if one doesn't exist
            console.log('Creating new SignalR connection for location tracking');
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/notificationHub")
                .withAutomaticReconnect({
                    nextRetryDelayInMilliseconds: retryContext => {
                        if (retryContext.elapsedMilliseconds < 2000) return 0;
                        if (retryContext.elapsedMilliseconds < 10000) return 2000;
                        if (retryContext.elapsedMilliseconds < 30000) return 10000;
                        return 30000;
                    }
                })
                .build();
        }
        
        // Store connection reference
        locationTrackingConnection = connection;
        
        // Remove existing handlers if they were already registered (prevents duplicates on retry)
        if (locationTrackingHandlersRegistered || isReusingConnection) {
            console.log('Removing existing location tracking handlers to prevent duplicates...');
            try {
                connection.off("ReceiveLocationUpdate");
            } catch (e) {
                console.warn('Could not remove existing handlers (this is OK if handlers were not registered):', e);
            }
            locationTrackingHandlersRegistered = false;
        }

        // Listen for location updates (register handler)
        connection.on("ReceiveLocationUpdate", function(data) {
            console.log("Received location update:", data);
            
            if (!data || !data.bookingId) {
                console.error("Invalid location update data:", data);
                return;
            }
            
            const bookingId = parseInt(data.bookingId);
            const lat = parseFloat(data.latitude);
            const lng = parseFloat(data.longitude);
            const distance = parseFloat(data.distanceKm || 0);
            const isWithin = data.isWithinGeofence === true || data.isWithinGeofence === 'true';
            const renterName = data.renterName || 'Unknown';
            const bikeName = data.bikeName || 'Unknown';
            const trackedAt = data.trackedAt || new Date().toISOString();
            
            // Validate coordinates
            if (isNaN(lat) || isNaN(lng) || lat === 0 || lng === 0) {
                console.error("Invalid coordinates in location update:", data);
                return;
            }
            
            // Update location data
            locationData[bookingId] = {
                latitude: lat,
                longitude: lng,
                renterName: renterName,
                bikeName: bikeName,
                distance: distance,
                isWithinGeofence: isWithin,
                trackedAt: trackedAt
            };

            // Update marker on map
            updateRenterMarker(
                bookingId,
                lat,
                lng,
                renterName,
                bikeName,
                distance,
                isWithin
            );

            // Update location display in the booking card
            updateLocationDisplay(bookingId, distance, isWithin, trackedAt);
            
            // Update "View on Map" button data attributes
            const bookingCard = document.querySelector(`[data-booking-id="${bookingId}"]`);
            if (bookingCard) {
                const viewButton = bookingCard.querySelector('button.btn-view-location');
                if (viewButton) {
                    viewButton.setAttribute('data-latitude', lat.toString());
                    viewButton.setAttribute('data-longitude', lng.toString());
                    viewButton.setAttribute('data-distance', distance.toString());
                    viewButton.setAttribute('data-is-within', isWithin.toString());
                }
            }
        });
        
        // Mark handlers as registered and initialization as complete
        locationTrackingHandlersRegistered = true;
        locationTrackingInitialized = true;

        // Only start connection if it's a new connection (not reused from _Layout)
        // Check connection state - if it's already connected, we can just add listeners
        if (connection.state === signalR.HubConnectionState.Disconnected) {
            connection.start()
                .then(function() {
                    console.log("Location tracking SignalR connected. Listening for location updates...");
                })
                .catch(function(err) {
                    console.error("Location tracking SignalR connection error:", err);
                    // Reset flags on error so it can be retried
                    locationTrackingHandlersRegistered = false;
                    locationTrackingInitialized = false;
                    locationTrackingConnection = null;
                    // Retry connection after 5 seconds
                    setTimeout(function() {
                        console.log("Retrying location tracking SignalR connection...");
                        initializeLocationTrackingSignalR();
                    }, 5000);
                });
        } else {
            console.log("Location tracking SignalR already connected. Listening for location updates...");
        }

        // Handle connection state changes (only register once)
        connection.onreconnecting(function() {
            console.log("Location tracking SignalR reconnecting...");
        });

        connection.onreconnected(function() {
            console.log("Location tracking SignalR reconnected");
        });

        connection.onclose(function() {
            console.log("Location tracking SignalR connection closed");
            // Reset flags on close so it can be reinitialized if needed
            locationTrackingInitialized = false;
            locationTrackingConnection = null;
            locationTrackingHandlersRegistered = false;
        });
    }

    function updateLocationDisplay(bookingId, distance, isWithinGeofence, trackedAt) {
        const bookingCard = document.querySelector(`[data-booking-id="${bookingId}"]`);
        if (!bookingCard) {
            console.warn('Booking card not found for booking ID:', bookingId);
            return;
        }

        // Find or create location display section
        let locationSection = bookingCard.querySelector('.location-display');
        if (!locationSection) {
            // Remove the "waiting for location" message if it exists
            const waitingDiv = bookingCard.querySelector('div[style*="background: var(--neutral-100)"]');
            if (waitingDiv) {
                waitingDiv.remove();
            }
            
            // Create location display if it doesn't exist
            const cardContent = bookingCard.querySelector('div > div:first-child');
            if (cardContent) {
                locationSection = document.createElement('div');
                locationSection.className = 'location-display';
                locationSection.style.cssText = 'margin-top: var(--space-3); padding: var(--space-3); background: var(--sage-subtle); border-radius: var(--radius-md);';
                cardContent.appendChild(locationSection);
            } else {
                console.warn('Card content not found for booking ID:', bookingId);
                return;
            }
        }
        
        // Enable the "View on Map" button
        const viewButton = bookingCard.querySelector('button.btn-view-location');
        if (!viewButton) {
            // Find the disabled button and replace it
            const disabledButton = bookingCard.querySelector('button[disabled]');
            if (disabledButton) {
                disabledButton.disabled = false;
                disabledButton.className = 'btn-minimal btn-minimal-primary btn-minimal-sm btn-view-location';
                disabledButton.innerHTML = '<i class="bi bi-map"></i> View on Map';
                // Get location data to set data attributes (safe from XSS)
                const locData = locationData[bookingId];
                if (locData) {
                    disabledButton.setAttribute('data-booking-id', bookingId.toString());
                    disabledButton.setAttribute('data-latitude', locData.latitude.toString());
                    disabledButton.setAttribute('data-longitude', locData.longitude.toString());
                    disabledButton.setAttribute('data-renter-name', locData.renterName || 'Unknown');
                    disabledButton.setAttribute('data-bike-name', locData.bikeName || 'Unknown');
                    disabledButton.setAttribute('data-distance', locData.distance.toString());
                    disabledButton.setAttribute('data-is-within', locData.isWithinGeofence.toString());
                }
            }
        }

        // Update location display
        let phTime;
        try {
            phTime = new Date(trackedAt).toLocaleString('en-US', {
                timeZone: 'Asia/Manila',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        } catch (e) {
            phTime = new Date().toLocaleString('en-US', {
                timeZone: 'Asia/Manila',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        const distanceValue = typeof distance === 'number' ? distance : parseFloat(distance || 0);
        const isWithin = isWithinGeofence === true || isWithinGeofence === 'true';

        locationSection.innerHTML = `
            <p style="margin: 0 0 var(--space-2) 0; font-weight: 600; color: var(--neutral-900);">
                <i class="bi bi-geo-alt"></i> Current Location <span style="color: var(--success); font-size: 0.75rem;">● Live</span>
            </p>
            <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                <strong>Distance from store:</strong> 
                <span style="color: ${isWithin ? 'var(--success)' : 'var(--error)'}; font-weight: 600;">
                    ${distanceValue.toFixed(2)} km
                </span>
            </p>
            <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-600);">
                <strong>Status:</strong> 
                ${isWithin 
                    ? '<span style="color: var(--success); font-weight: 600;"><i class="bi bi-check-circle"></i> Within Geofence</span>'
                    : '<span style="color: var(--error); font-weight: 600;"><i class="bi bi-exclamation-triangle"></i> Outside Geofence</span>'
                }
            </p>
            <p style="margin: 0; font-size: 0.75rem; color: var(--neutral-500); margin-top: var(--space-1);">
                Last updated: ${phTime}
            </p>
        `;
    }

    function addRenterMarker(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence) {
        updateRenterMarker(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence);
    }

    function updateRenterMarker(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence) {
        // Remove existing marker if any
        if (markers[bookingId]) {
            map.removeLayer(markers[bookingId]);
        }

        // Create marker with color based on geofence status
        const markerIcon = L.icon({
            iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${isWithinGeofence ? 'blue' : 'red'}.png`,
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        const marker = L.marker([lat, lng], { 
            icon: markerIcon,
            title: `${renterName} - ${bikeName}`
        })
        .addTo(map)
        .bindPopup(`
            <strong>${renterName}</strong><br>
            ${bikeName}<br>
            Distance: ${distance.toFixed(2)} km<br>
            Status: ${isWithinGeofence ? '<span style="color: green;">✓ Within Geofence</span>' : '<span style="color: red;">⚠ Outside Geofence</span>'}<br>
            <small style="color: #666;">Updated: ${new Date().toLocaleTimeString()}</small>
        `);

        markers[bookingId] = marker;

        // Smoothly animate marker movement if it already exists
        if (markers[bookingId] && markers[bookingId].getLatLng) {
            const currentPos = markers[bookingId].getLatLng();
            if (currentPos.lat !== lat || currentPos.lng !== lng) {
                // Animate marker movement
                marker.setLatLng([lat, lng], { animate: true, duration: 0.5 });
            }
        }

        // Fit map to show all markers
        if (Object.keys(markers).length > 0) {
            const bounds = L.latLngBounds(Object.values(markers).map(m => m.getLatLng()));
            map.fitBounds(bounds, { padding: [50, 50] });
        }
    }

    function showLocationOnMap(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence) {
        // Add or update marker
        addRenterMarker(bookingId, lat, lng, renterName, bikeName, distance, isWithinGeofence);

        // Center map on this location
        map.setView([lat, lng], 15);

        // Open popup
        if (markers[bookingId]) {
            markers[bookingId].openPopup();
        }
    }

    // Time remaining countdown
    function getPhilippineTime() {
        const now = new Date();
        const phTimeStr = now.toLocaleString('en-US', { 
            timeZone: 'Asia/Manila',
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: false
        });
        const parts = phTimeStr.split(', ');
        const dateParts = parts[0].split('/');
        const timeParts = parts[1].split(':');
        return new Date(
            parseInt(dateParts[2]), parseInt(dateParts[0]) - 1, parseInt(dateParts[1]),
            parseInt(timeParts[0]), parseInt(timeParts[1]), parseInt(timeParts[2])
        );
    }

    function updateTimeRemaining() {
        document.querySelectorAll('.time-remaining').forEach(function(element) {
            const endDateStr = element.getAttribute('data-end-date');
            if (!endDateStr) return;
            
            const endDateParts = endDateStr.split('T');
            const dateParts = endDateParts[0].split('-');
            const timeParts = endDateParts[1].split(':');
            
            const endDate = new Date(
                parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]),
                parseInt(timeParts[0]), parseInt(timeParts[1]), parseInt(timeParts[2])
            );
            
            const nowPhilippine = getPhilippineTime();
            const diff = endDate.getTime() - nowPhilippine.getTime();
            
            if (diff <= 0) {
                element.textContent = 'OVERDUE';
                element.style.color = 'var(--error)';
            } else {
                const totalSeconds = Math.floor(diff / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                if (hours > 0) {
                    element.textContent = `${hours}h ${minutes}m remaining`;
                } else if (minutes > 0) {
                    element.textContent = `${minutes}m ${seconds}s remaining`;
                } else {
                    element.textContent = `${seconds}s remaining`;
                }
            }
        });
    }

    updateTimeRemaining();
    setInterval(updateTimeRemaining, 1000);
</script>

