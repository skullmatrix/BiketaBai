@page "{bookingId:int}"
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize]
@model TrackLocationModel
@{
    ViewData["Title"] = "Location Tracking";
}

<div class="page-container">
    <div style="max-width: 1200px; margin: 0 auto;">
        @if (Model.Booking == null)
        {
            <div class="alert-minimal alert-minimal-error">
                <i class="bi bi-exclamation-triangle-fill"></i>
                <div>Booking not found</div>
            </div>
        }
        else
        {
            <div class="page-header">
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: var(--space-4);">
                    <h1 class="page-title">
                        <i class="bi bi-geo-alt-fill"></i> Location Tracking
                    </h1>
                    <a href="/Dashboard/Renter" class="btn-minimal btn-minimal-ghost">
                        <i class="bi bi-arrow-left"></i> Back to Dashboard
                    </a>
                </div>
            </div>

            <!-- Booking Info -->
            <div class="card-minimal mb-4">
                <div class="card-minimal-header">
                    <h2 class="card-minimal-title">
                        <i class="bi bi-calendar-check"></i> Booking Details
                    </h2>
                </div>
                <div class="grid-minimal grid-minimal-2">
                    <div>
                        <div style="font-size: 0.875rem; color: var(--neutral-600); margin-bottom: var(--space-1);">Bike</div>
                        <div style="font-weight: 600; margin-bottom: var(--space-3);">@Model.Booking.Bike.Brand @Model.Booking.Bike.Model</div>
                        
                        <div style="font-size: 0.875rem; color: var(--neutral-600); margin-bottom: var(--space-1);">Owner</div>
                        <div style="font-weight: 600; margin-bottom: var(--space-3);">@Model.Booking.Bike.Owner.FullName</div>
                        
                        <div style="font-size: 0.875rem; color: var(--neutral-600); margin-bottom: var(--space-1);">Store</div>
                        <div style="font-weight: 600;">@(Model.PrimaryStore?.StoreName ?? "Store Location")</div>
                    </div>
                    <div>
                        <div style="font-size: 0.875rem; color: var(--neutral-600); margin-bottom: var(--space-1);">Start</div>
                        <div style="font-weight: 600; margin-bottom: var(--space-3);">@Model.Booking.StartDate.ToString("MMM dd, yyyy hh:mm tt")</div>
                        
                        <div style="font-size: 0.875rem; color: var(--neutral-600); margin-bottom: var(--space-1);">End</div>
                        <div style="font-weight: 600; margin-bottom: var(--space-3);">@Model.Booking.EndDate.ToString("MMM dd, yyyy hh:mm tt")</div>
                        
                        <div style="font-size: 0.875rem; color: var(--neutral-600); margin-bottom: var(--space-1);">Geofence Radius</div>
                        <div style="font-weight: 600; color: var(--sage-primary); margin-bottom: var(--space-3);">@Model.GeofenceRadiusKm km</div>
                        
                        @if (Model.StoreLatitude.HasValue && Model.StoreLongitude.HasValue)
                        {
                            <div style="font-size: 0.875rem; color: var(--neutral-600); margin-bottom: var(--space-1);">Store Location</div>
                            <div style="font-weight: 600; font-family: monospace; font-size: 0.875rem; color: var(--neutral-700);">
                                @Model.StoreLatitude.Value.ToString("F6"), @Model.StoreLongitude.Value.ToString("F6")
                            </div>
                        }
                    </div>
                </div>
            </div>

            <!-- Location Status -->
            <div class="card-minimal mb-4" id="locationStatusCard">
                <div style="text-align: center; padding: var(--space-6);">
                    <div id="locationStatus" class="mb-3">
                        <i class="bi bi-hourglass-split" style="font-size: 3rem; color: var(--neutral-400);"></i>
                        <p class="mt-3" style="color: var(--neutral-600);">Requesting location access...</p>
                    </div>
                    <div id="locationInfo" style="display: none;">
                        <h4 id="statusText" class="mb-3" style="color: var(--sage-primary);"></h4>
                        <div style="display: flex; flex-direction: column; gap: var(--space-2); text-align: left; max-width: 400px; margin: 0 auto;">
                            <p style="margin: 0;"><strong>Distance from Store:</strong> <span id="distanceText" style="color: var(--sage-primary); font-weight: 600;">-</span></p>
                            <p style="margin: 0;"><strong>Your Location:</strong> <span id="coordinatesText" style="color: var(--neutral-600);">-</span></p>
                            @if (Model.StoreLatitude.HasValue && Model.StoreLongitude.HasValue)
                            {
                                <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-500);">
                                    <strong>Store Location:</strong> 
                                    <span style="font-family: monospace; color: var(--neutral-600);">
                                        @Model.StoreLatitude.Value.ToString("F6"), @Model.StoreLongitude.Value.ToString("F6")
                                    </span>
                                </p>
                            }
                            <p style="margin: 0; font-size: 0.875rem; color: var(--neutral-500);">Last updated: <span id="lastUpdateText">-</span></p>
                            <p style="margin: 0; font-size: 0.75rem; color: var(--neutral-400);" id="sendStatus">
                                <i class="bi bi-hourglass-split"></i> Preparing to send location...
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Map Container -->
            <div class="card-minimal mb-4">
                <div style="padding: 0; border-radius: var(--radius-lg); overflow: hidden;">
                    <div id="map" style="height: 400px; width: 100%;"></div>
                </div>
            </div>

            <!-- Instructions -->
            <div class="alert-minimal alert-minimal-info mb-4">
                <i class="bi bi-info-circle-fill"></i>
                <div>
                    <strong>How Location Tracking Works</strong>
                    <ul style="margin: var(--space-2) 0 0 0; padding-left: var(--space-5);">
                        <li>Your location is automatically tracked every 30 seconds while this page is open for live tracking</li>
                        <li>You must allow location access when prompted by your browser</li>
                        <li>If you go outside the @Model.GeofenceRadiusKm km radius, you'll receive SMS warnings</li>
                        <li>Keep this page open during your rental to ensure continuous tracking</li>
                    </ul>
                </div>
            </div>

            <!-- Warning Alert -->
            <div class="alert-minimal alert-minimal-warning" id="warningAlert" style="display: none;">
                <i class="bi bi-exclamation-triangle-fill"></i>
                <div>
                    <strong>Geofence Warning</strong>
                    <p id="warningMessage" style="margin: var(--space-2) 0 0 0;"></p>
                </div>
            </div>

            <!-- Connection Status & Debug Panel -->
            <div class="card-minimal mb-4">
                <div class="card-minimal-header">
                    <h2 class="card-minimal-title">
                        <i class="bi bi-terminal"></i> Debug & Connection Status
                    </h2>
                </div>
                <div class="card-minimal-body">
                    <!-- SignalR Connection Status -->
                    <div class="mb-4">
                        <h4 style="font-size: 1rem; font-weight: 600; margin-bottom: var(--space-2);">
                            <i class="bi bi-wifi"></i> SignalR Connection Status
                        </h4>
                        <div style="padding: var(--space-3); background: var(--neutral-100); border-radius: var(--radius-md);">
                            <p style="margin: 0 0 var(--space-2) 0;">
                                <strong>Status:</strong> <span id="signalRStatusText">Checking...</span>
                            </p>
                            <p style="margin: 0 0 var(--space-2) 0;">
                                <strong>Connection State:</strong> <span id="signalRStateText">-</span>
                            </p>
                            <p style="margin: 0;">
                                <strong>Location Sending:</strong> <span id="locationSendingStatus">Not started</span>
                            </p>
                        </div>
                        <div style="display: flex; gap: var(--space-2); margin-top: var(--space-3);">
                            <button type="button" class="btn-minimal btn-minimal-secondary btn-minimal-sm" onclick="checkSignalRConnection()">
                                <i class="bi bi-arrow-clockwise"></i> Refresh Status
                            </button>
                            <button type="button" class="btn-minimal btn-minimal-secondary btn-minimal-sm" onclick="clearDebugLog()">
                                <i class="bi bi-trash"></i> Clear Log
                            </button>
                        </div>
                    </div>

                    <!-- Debug Console -->
                    <div>
                        <h4 style="font-size: 1rem; font-weight: 600; margin-bottom: var(--space-2);">
                            <i class="bi bi-terminal"></i> Debug Console
                        </h4>
                        <div id="debugLog" style="background: #1e1e1e; color: #d4d4d4; padding: var(--space-4); border-radius: var(--radius-md); font-family: monospace; font-size: 0.875rem; max-height: 300px; overflow-y: auto; min-height: 150px;">
                            <div style="color: #858585;">Initializing debug console...</div>
                        </div>
                    </div>
                </div>
            </div>
        }
    </div>
</div>

<!-- Load Leaflet CSS and JS for map -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
    // Debug logging functions (similar to admin test page)
    let debugLog = [];
    
    // Test debug console immediately when script loads
    (function() {
        setTimeout(function() {
            const logDiv = document.getElementById('debugLog');
            if (logDiv) {
                logDiv.innerHTML = '<div style="color: #4ec9b0;">[Initializing...] Debug console ready</div>';
                console.log('üìç Debug console initialized');
            }
        }, 100);
    })();
    
    function addDebugLog(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${message}`;
        debugLog.push({ message: logEntry, type: type });
        
        // Also log to browser console
        if (type === 'error') {
            console.error(logEntry);
        } else if (type === 'success') {
            console.log('‚úÖ', logEntry);
        } else {
            console.log('üìç', logEntry);
        }
        
        const logDiv = document.getElementById('debugLog');
        if (logDiv) {
            // Clear "Waiting for logs..." or "Initializing..." message on first log
            if (logDiv.innerHTML.includes('Initializing') || logDiv.innerHTML.includes('Waiting')) {
                logDiv.innerHTML = '';
            }
            
            const color = type === 'error' ? '#f48771' : type === 'success' ? '#4ec9b0' : '#d4d4d4';
            logDiv.innerHTML += `<div style="color: ${color}; margin-bottom: 2px;">${logEntry}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        } else {
            console.warn('Debug log div not found!');
        }
    }
    
    function clearDebugLog() {
        debugLog = [];
        const logDiv = document.getElementById('debugLog');
        if (logDiv) {
            logDiv.innerHTML = '<div style="color: #858585;">Log cleared...</div>';
        }
    }
    
    // SignalR Connection Status Checker
    function checkSignalRConnection(retryCount = 0) {
        const statusEl = document.getElementById('signalRStatusText');
        const stateEl = document.getElementById('signalRStateText');
        
        if (!statusEl || !stateEl) {
            addDebugLog('‚ö†Ô∏è SignalR status elements not found yet. Retrying...', 'info');
            if (retryCount < 5) {
                setTimeout(() => checkSignalRConnection(retryCount + 1), 500);
            }
            return;
        }
        
        addDebugLog('Checking SignalR connection status...', 'info');
        
        if (typeof signalR === 'undefined') {
            statusEl.textContent = '‚ùå SignalR library not loaded';
            stateEl.textContent = 'N/A';
            addDebugLog('ERROR: SignalR library not loaded! Waiting for library...', 'error');
            
            // Retry after 2 seconds if library not loaded
            if (retryCount < 10) {
                setTimeout(() => checkSignalRConnection(retryCount + 1), 2000);
            }
            return;
        }
        
        addDebugLog('‚úÖ SignalR library loaded', 'success');
        
        // Check global connection - wait for it to be initialized
        let conn = null;
        if (typeof window.BiketaBaiNotifications !== 'undefined' && window.BiketaBaiNotifications.connection) {
            conn = window.BiketaBaiNotifications.connection;
            addDebugLog('‚úÖ Found global SignalR connection', 'success');
        } else if (typeof notificationHubConnection !== 'undefined' && notificationHubConnection) {
            conn = notificationHubConnection;
            addDebugLog('‚úÖ Found notification hub connection', 'success');
        } else {
            // Connection might not be initialized yet - wait and retry
            if (retryCount < 5) {
                addDebugLog(`‚ö†Ô∏è No SignalR connection found yet (attempt ${retryCount + 1}/5). Waiting 2 seconds...`, 'info');
                statusEl.textContent = '‚è≥ Waiting for connection...';
                stateEl.textContent = 'Checking...';
                setTimeout(() => checkSignalRConnection(retryCount + 1), 2000);
                return;
            } else {
                addDebugLog('‚ùå WARNING: No SignalR connection found after multiple attempts!', 'error');
                addDebugLog('üí° Try: 1) Refresh the page, 2) Check browser console for errors, 3) Ensure you are logged in', 'info');
                statusEl.textContent = '‚ùå No Connection';
                stateEl.textContent = 'Not Found';
                return;
            }
        }
        
        if (conn) {
            const state = conn.state;
            let stateText = 'Unknown';
            let stateNum = state;
            
            if (state === signalR.HubConnectionState.Connected || state === 1) {
                stateText = '‚úÖ Connected';
                addDebugLog('Connection state: Connected', 'success');
            } else if (state === signalR.HubConnectionState.Connecting || state === 0) {
                stateText = 'üîÑ Connecting...';
                addDebugLog('Connection state: Connecting', 'info');
            } else if (state === signalR.HubConnectionState.Disconnected || state === 2) {
                stateText = '‚ùå Disconnected';
                addDebugLog('Connection state: Disconnected', 'error');
            } else if (state === signalR.HubConnectionState.Reconnecting || state === 3) {
                stateText = 'üîÑ Reconnecting...';
                addDebugLog('Connection state: Reconnecting', 'info');
            }
            
            statusEl.textContent = stateText;
            stateEl.textContent = `State ${stateNum}`;
        }
    }

    let map;
    let renterMarker;
    let storeMarker;
    let geofenceCircle;
    let locationTrail;
    let watchId;
    let updateInterval;
    
    // Store location history for trail
    const locationHistory = [];
    
    @if (Model.LocationHistory.Any())
    {
        <text>
        // Initialize location history from server
        @foreach (var loc in Model.LocationHistory)
        {
            <text>
            locationHistory.push({
                lat: @loc.Latitude,
                lng: @loc.Longitude,
                timestamp: '@loc.TrackedAt.ToString("yyyy-MM-ddTHH:mm:ss")',
                isWithin: @loc.IsWithinGeofence.ToString().ToLower()
            });
            </text>
        }
        </text>
    }

    // Initialize map when page loads
    document.addEventListener('DOMContentLoaded', function() {
        console.log('üìç TrackLocation page DOMContentLoaded fired');
        
        // Wait a moment for DOM to be fully ready, then initialize
        setTimeout(function() {
            // Test if debug console div exists
            const testDiv = document.getElementById('debugLog');
            if (testDiv) {
                console.log('‚úÖ Debug console div found');
            } else {
                console.error('‚ùå Debug console div NOT found!');
            }
            
            // Add initial logs
            addDebugLog('üìç Page loaded, initializing location tracking...', 'info');
            addDebugLog('üìç Booking ID: ' + @Model.Booking.BookingId, 'info');
            
            // Check SignalR connection status after a delay to allow SignalR to load
            setTimeout(() => {
                checkSignalRConnection();
            }, 2000);
            
            // Also check periodically
            setInterval(() => {
                checkSignalRConnection();
            }, 10000); // Check every 10 seconds
            
            // Initialize location tracking
            checkPermissionAndInitialize();
        }, 300); // Small delay to ensure DOM is ready
        
        // Make functions globally accessible for buttons and debugging after page load
        window.checkPermissionAndInitialize = checkPermissionAndInitialize;
        window.requestLocationPermission = requestLocationPermission;
        window.initializeLocation = initializeLocation;
        window.checkSignalRConnection = checkSignalRConnection;
        window.clearDebugLog = clearDebugLog;
        window.testLocationAccess = function() {
            addDebugLog('üß™ Testing location access...', 'info');
            if (!navigator.geolocation) {
                addDebugLog('‚ùå Geolocation not supported', 'error');
                return;
            }
            navigator.geolocation.getCurrentPosition(
                function(pos) {
                    addDebugLog('‚úÖ Test successful: ' + pos.coords.latitude + ', ' + pos.coords.longitude, 'success');
                    alert('Location access works! Coordinates: ' + pos.coords.latitude + ', ' + pos.coords.longitude);
                },
                function(err) {
                    addDebugLog('‚ùå Test failed: ' + err.code + ' - ' + err.message, 'error');
                    alert('Location access failed: ' + err.message);
                }
            );
        };
    });
    
    // Check permission status first, then request location
    async function checkPermissionAndInitialize() {
        const bookingId = @Model.Booking.BookingId;
        const locationStatusEl = document.getElementById('locationStatus');
        
        if (!navigator.geolocation) {
            if (locationStatusEl) {
                locationStatusEl.innerHTML = 
                    '<i class="bi bi-exclamation-triangle" style="font-size: 3rem; color: var(--error);"></i>' +
                    '<p class="mt-2" style="color: var(--error);">Geolocation is not supported by your browser.</p>';
            }
            return;
        }

        // Check permission status using Permissions API if available
        let permissionStatus = 'prompt'; // default
        
        try {
            if (navigator.permissions && navigator.permissions.query) {
                const result = await navigator.permissions.query({ name: 'geolocation' });
                permissionStatus = result.state;
                addDebugLog('üîç Permission status: ' + permissionStatus, 'info');
                
                // Listen for permission changes
                result.onchange = function() {
                    addDebugLog('üîî Permission status changed to: ' + result.state, 'info');
                    if (result.state === 'granted') {
                        initializeLocation();
                    } else if (result.state === 'denied') {
                        showPermissionDeniedUI(bookingId);
                    }
                };
                
                if (result.state === 'denied') {
                    addDebugLog('‚ö†Ô∏è Permission denied, showing permission request UI', 'error');
                    showPermissionDeniedUI(bookingId);
                    return;
                }
            }
        } catch (error) {
            addDebugLog('‚ö†Ô∏è Permissions API not available or failed: ' + error.message, 'info');
            // Continue to try requesting location anyway
        }
        
        // If permission is granted or prompt, try to get location
        initializeLocation();
    }
    
    function initializeLocation() {
        const bookingId = @Model.Booking.BookingId;
        const locationStatusEl = document.getElementById('locationStatus');
        
        addDebugLog('üìç Requesting location access...', 'info');
        
        // Update status to show we're requesting
        if (locationStatusEl) {
            locationStatusEl.innerHTML = 
                '<i class="bi bi-hourglass-split" style="font-size: 3rem; color: var(--neutral-400);"></i>' +
                '<p class="mt-3" style="color: var(--neutral-600);">Requesting location access...</p>' +
                '<p style="font-size: 0.875rem; color: var(--neutral-500); margin-top: var(--space-2);">Please allow location access when prompted by your browser.</p>';
        }
        
        // Use getCurrentPosition with multiple fallback strategies
        requestLocationWithFallback(bookingId, 0);
    }
    
    function requestLocationWithFallback(bookingId, attemptNumber) {
        const maxAttempts = 3;
        let locationReceived = false;
        
        const options = [
            { enableHighAccuracy: false, timeout: 3000, maximumAge: 600000 },  // Try cached first (fastest)
            { enableHighAccuracy: false, timeout: 8000, maximumAge: 0 },       // Try network location
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }        // Try GPS (slowest but most accurate)
        ];
        
        const currentOptions = options[Math.min(attemptNumber, options.length - 1)];
        addDebugLog(`üìç Attempt ${attemptNumber + 1}/${maxAttempts} with options: timeout=${currentOptions.timeout}ms, maxAge=${currentOptions.maximumAge}ms, highAccuracy=${currentOptions.enableHighAccuracy}`, 'info');
        
        navigator.geolocation.getCurrentPosition(
            function(position) {
                if (!locationReceived) {
                    locationReceived = true;
                    addDebugLog('‚úÖ Location obtained: ' + position.coords.latitude + ', ' + position.coords.longitude + ' (accuracy: ' + position.coords.accuracy + 'm)', 'success');
                    
                    // Hide "Requesting location access" status immediately
                    const locationStatusEl = document.getElementById('locationStatus');
                    const locationInfoEl = document.getElementById('locationInfo');
                    if (locationStatusEl) locationStatusEl.style.display = 'none';
                    if (locationInfoEl) locationInfoEl.style.display = 'block';
                    
                    initMap(position.coords.latitude, position.coords.longitude);
                    startTracking();
                }
            },
            function(error) {
                let errorType = 'Unknown';
                if (error.code === 1) errorType = 'PERMISSION_DENIED';
                else if (error.code === 2) errorType = 'POSITION_UNAVAILABLE';
                else if (error.code === 3) errorType = 'TIMEOUT';
                
                addDebugLog(`‚ùå Attempt ${attemptNumber + 1} failed: ${errorType} - ${error.message}`, 'error');
                
                // Try next fallback option
                if (attemptNumber < maxAttempts - 1) {
                    addDebugLog(`üîÑ Retrying with different options...`, 'info');
                    setTimeout(() => {
                        requestLocationWithFallback(bookingId, attemptNumber + 1);
                    }, 1000);
                } else {
                    // All attempts failed
                    addDebugLog('‚ùå All location request attempts failed', 'error');
                    handleLocationError(error, bookingId);
                }
            },
            currentOptions
        );
    }
    
    function showPermissionDeniedUI(bookingId) {
        const locationStatusEl = document.getElementById('locationStatus');
        if (!locationStatusEl) return;
        
        locationStatusEl.innerHTML = 
            '<i class="bi bi-exclamation-triangle" style="font-size: 3rem; color: var(--error);"></i>' +
            '<h4 style="color: var(--error); margin: var(--space-3) 0;">Location Access Denied</h4>' +
            '<p style="color: var(--neutral-600); margin-bottom: var(--space-4);">Location tracking is required for this rental. Please enable location access to continue.</p>' +
            '<div style="display: flex; flex-direction: column; gap: var(--space-2); align-items: center;">' +
            '<button onclick="requestLocationPermission(' + bookingId + ')" class="btn-minimal btn-minimal-primary">' +
            '<i class="bi bi-geo-alt"></i> Request Location Permission' +
            '</button>' +
            '<p style="font-size: 0.875rem; color: var(--neutral-500); margin-top: var(--space-2);">If you\'ve already denied permission, please enable it in your browser settings.</p>' +
            '</div>';
        
        // Notify owner
        fetch('/Api/LocationPermissionDenied', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bookingId: bookingId })
        }).catch(err => console.error('Error notifying owner:', err));
    }
    
    function requestLocationPermission(bookingId) {
        if (!bookingId) {
            bookingId = @Model.Booking.BookingId;
        }
        
        addDebugLog('üîê Requesting location permission explicitly... Booking ID: ' + bookingId, 'info');
        const locationStatusEl = document.getElementById('locationStatus');
        
        if (!navigator.geolocation) {
            addDebugLog('‚ùå Geolocation API not supported', 'error');
            if (locationStatusEl) {
                locationStatusEl.innerHTML = 
                    '<i class="bi bi-exclamation-triangle" style="font-size: 3rem; color: var(--error);"></i>' +
                    '<p class="mt-2" style="color: var(--error);">Geolocation is not supported by your browser.</p>';
            }
            return;
        }
        
        // Update UI to show we're requesting
        if (locationStatusEl) {
            locationStatusEl.innerHTML = 
                '<i class="bi bi-hourglass-split" style="font-size: 3rem; color: var(--neutral-400);"></i>' +
                '<p class="mt-3" style="color: var(--neutral-600);">Requesting location permission...</p>' +
                '<p style="font-size: 0.875rem; color: var(--neutral-500); margin-top: var(--space-2);">Please allow location access when prompted by your browser.</p>';
        }
        
        addDebugLog('üìç Calling navigator.geolocation.getCurrentPosition()...', 'info');
        
        // Request permission explicitly
        navigator.geolocation.getCurrentPosition(
            function(position) {
                addDebugLog('‚úÖ Location permission granted!', 'success');
                addDebugLog('üìç Coordinates: ' + position.coords.latitude + ', ' + position.coords.longitude, 'success');
                addDebugLog('üìç Accuracy: ' + position.coords.accuracy + ' meters', 'success');
                
                const locationStatusEl = document.getElementById('locationStatus');
                const locationInfoEl = document.getElementById('locationInfo');
                if (locationStatusEl) locationStatusEl.style.display = 'none';
                if (locationInfoEl) locationInfoEl.style.display = 'block';
                
                initMap(position.coords.latitude, position.coords.longitude);
                startTracking();
            },
            function(error) {
                addDebugLog('‚ùå Permission request failed', 'error');
                
                let errorType = 'Unknown';
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        errorType = 'PERMISSION_DENIED';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorType = 'POSITION_UNAVAILABLE';
                        break;
                    case error.TIMEOUT:
                        errorType = 'TIMEOUT';
                        break;
                }
                addDebugLog('Error code: ' + error.code + ' (' + errorType + ')', 'error');
                addDebugLog('Error message: ' + error.message, 'error');
                
                handleLocationError(error, bookingId);
            },
            {
                enableHighAccuracy: false,
                timeout: 10000,
                maximumAge: 0
            }
        );
    }
    
    function handleLocationError(error, bookingId) {
        const locationStatusEl = document.getElementById('locationStatus');
        if (!locationStatusEl) return;
        
        let errorMessage = '';
        let errorIcon = 'bi-exclamation-triangle';
        let showPermissionButton = false;
        
        switch(error.code) {
            case error.PERMISSION_DENIED:
                errorMessage = 'Location access was denied. Location tracking is required for this rental.';
                errorIcon = 'bi-shield-exclamation';
                showPermissionButton = true;
                
                // Notify owner if location permission is denied
                fetch('/Api/LocationPermissionDenied', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bookingId: bookingId })
                }).then(response => response.json())
                  .then(result => {
                      if (result.success) {
                          console.log('Owner notified about location permission denial');
                      }
                  })
                  .catch(err => console.error('Error notifying owner:', err));
                break;
            case error.POSITION_UNAVAILABLE:
                errorMessage = 'Location information is unavailable. Please check your device location settings and ensure GPS/Location services are enabled.';
                errorIcon = 'bi-geo-alt-slash';
                break;
            case error.TIMEOUT:
                errorMessage = 'Location request timed out. Your device may be having trouble getting a GPS signal. Please try again.';
                errorIcon = 'bi-clock-history';
                break;
            default:
                errorMessage = 'An unknown error occurred while requesting location. Please try again or refresh the page.';
                break;
        }
        
        let buttonHTML = '';
        if (showPermissionButton) {
            buttonHTML = 
                '<button onclick="window.requestLocationPermission(' + bookingId + ')" class="btn-minimal btn-minimal-primary mt-3" style="margin-top: 1rem;">' +
                '<i class="bi bi-geo-alt"></i> Request Location Permission Again' +
                '</button>' +
                '<p style="font-size: 0.875rem; color: var(--neutral-500); margin-top: var(--space-2);">Or enable location access in your browser settings and refresh this page.</p>';
        } else {
            buttonHTML = 
                '<button onclick="window.checkPermissionAndInitialize()" class="btn-minimal btn-minimal-primary mt-3" style="margin-top: 1rem;">' +
                '<i class="bi bi-arrow-clockwise"></i> Try Again' +
                '</button>';
        }
        
        locationStatusEl.innerHTML = 
            '<i class="bi ' + errorIcon + '" style="font-size: 3rem; color: var(--error);"></i>' +
            '<h4 style="color: var(--error); margin: var(--space-3) 0;">Location Access Error</h4>' +
            '<p style="color: var(--neutral-600); margin-bottom: var(--space-4);">' + errorMessage + '</p>' +
            buttonHTML +
            '<div style="margin-top: var(--space-4); padding: var(--space-3); background: var(--neutral-100); border-radius: var(--radius-md);">' +
            '<p style="font-size: 0.875rem; font-weight: 600; margin-bottom: var(--space-2);">Troubleshooting Tips:</p>' +
            '<ul style="font-size: 0.875rem; color: var(--neutral-600); text-align: left; margin: 0; padding-left: var(--space-4);">' +
            '<li>Check that location services are enabled on your device</li>' +
            '<li>Ensure your browser has permission to access location</li>' +
            '<li>Try refreshing the page</li>' +
            '<li>If using mobile, ensure GPS/Location is turned on</li>' +
            '</ul>' +
            '</div>';
    }


    function initMap(lat, lng) {
        // Store coordinates from model
        const storeLat = @(Model.StoreLatitude?.ToString("F6") ?? "14.5995");
        const storeLng = @(Model.StoreLongitude?.ToString("F6") ?? "120.9842");
        const radius = @Model.GeofenceRadiusKm * 1000; // Convert km to meters

        // Create map centered on store
        map = L.map('map').setView([storeLat, storeLng], 13);

        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        // Add store marker with store name
        const storeName = '@(Model.PrimaryStore?.StoreName ?? "Store Location")';
        storeMarker = L.marker([storeLat, storeLng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [30, 48],
                iconAnchor: [15, 48],
                popupAnchor: [1, -40],
                shadowSize: [41, 41]
            }),
            zIndexOffset: 500
        }).addTo(map).bindPopup(`
            <div style="text-align: center; min-width: 150px;">
                <strong style="font-size: 1.1em;">${storeName}</strong><br>
                <small style="color: #666;">Store Location</small><br>
                <hr style="margin: 8px 0;">
                <strong>Coordinates:</strong><br>
                <code style="font-size: 0.85em;">${storeLat.toFixed(6)}, ${storeLng.toFixed(6)}</code><br>
                <strong>Geofence Radius:</strong> @Model.GeofenceRadiusKm km
            </div>
        `);

        // Add geofence circle - make it more visible
        geofenceCircle = L.circle([storeLat, storeLng], {
            color: '#87A96B',
            fillColor: '#E8F0E3',
            fillOpacity: 0.4, // Increased opacity for better visibility
            weight: 3, // Thicker border
            radius: radius
        }).addTo(map).bindTooltip(`Geofence: @Model.GeofenceRadiusKm km radius`, {
            permanent: false,
            direction: 'center',
            className: 'geofence-tooltip'
        });

        // Add renter marker with pulsing effect
        renterMarker = L.marker([lat, lng], {
            icon: L.icon({
                iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [30, 48],
                iconAnchor: [15, 48],
                popupAnchor: [1, -40],
                shadowSize: [41, 41]
            }),
            zIndexOffset: 1000
        }).addTo(map).bindPopup(`
            <div style="text-align: center;">
                <strong>Your Location</strong><br>
                <code style="font-size: 0.9em;">${lat.toFixed(6)}, ${lng.toFixed(6)}</code><br>
                <small style="color: #666;">
                    <i class="bi bi-circle-fill" style="color: #28a745; font-size: 0.6em;"></i> Live Tracking
                </small>
            </div>
        `);
        
        // Draw location trail if history exists
        if (locationHistory.length > 1) {
            const trailPoints = locationHistory.map(point => [point.lat, point.lng]);
            // Use the last point's geofence status for trail color, or default to blue
            const lastPoint = locationHistory[locationHistory.length - 1];
            const trailColor = (lastPoint && lastPoint.isWithin !== undefined) 
                ? (lastPoint.isWithin ? '#3388ff' : '#ff3333')
                : '#3388ff';
            
            locationTrail = L.polyline(trailPoints, {
                color: trailColor,
                weight: 3,
                opacity: 0.6,
                smoothFactor: 1
            }).addTo(map);
            
            addDebugLog('üìç Location trail drawn with ' + locationHistory.length + ' points', 'success');
        }

        // Fit map to show both markers, geofence, and trail with proper padding
        const group = new L.featureGroup([storeMarker, renterMarker, geofenceCircle]);
        if (locationTrail) {
            group.addLayer(locationTrail);
        }
        const bounds = group.getBounds();
        map.fitBounds(bounds, { 
            padding: [50, 50],
            maxZoom: 15 // Don't zoom in too much if markers are close
        });
        
        // Ensure geofence circle is visible - log for debugging
        addDebugLog('üìç Store location: ' + storeLat + ', ' + storeLng, 'info');
        addDebugLog('üìç Geofence radius: ' + radius + ' meters (' + @Model.GeofenceRadiusKm + ' km)', 'info');
        addDebugLog('üìç Renter location: ' + lat + ', ' + lng, 'info');
        addDebugLog('üìç Geofence circle added to map', 'success');
        addDebugLog('üìç Location history points: ' + locationHistory.length, 'info');
    }

    function startTracking() {
        addDebugLog('üöÄ Starting location tracking...', 'info');
        updateLocationSendingStatus('Starting...');
        
        // Send location immediately when tracking starts (with sendToServer = true)
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    addDebugLog('üìç Initial location received, sending to server...', 'success');
                    updateLocation(position, true); // Always send first location
                },
                function(error) {
                    addDebugLog('‚ùå Error getting initial location: ' + error.message, 'error');
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0 // Get fresh location immediately
                }
            );
        }

        // Update location every 10 seconds for more frequent live tracking
        updateInterval = setInterval(function() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        updateLocation(position, true); // Send to server
                    },
                    function(error) {
                        addDebugLog('‚ùå Error getting location: ' + error.message, 'error');
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 10000 // Accept location up to 10 seconds old
                    }
                );
            }
        }, 10000); // 10 seconds for more frequent live tracking

        // Also watch position continuously for smoother UI updates (but don't send every watch update)
        watchId = navigator.geolocation.watchPosition(
            function(position) {
                updateLocation(position, false); // Update UI but don't send to server (interval handles that)
            }, 
            function(error) {
                addDebugLog('‚ùå Error watching location: ' + error.message, 'error');
            }, 
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 5000 // Accept location up to 5 seconds old for smoother UI updates
            }
        );
        
        addDebugLog('‚úÖ Location tracking started. Updates will be sent every 10 seconds for live tracking.', 'success');
        updateLocationSendingStatus('Active - Sending every 10 seconds');
    }

    function updateLocation(position, sendToServer = true) {
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;

        addDebugLog('üìç Location update received: ' + lat.toFixed(6) + ', ' + lng.toFixed(6) + ' (sendToServer: ' + sendToServer + ')', 'info');

        // Calculate distance from store
        const storeLat = @(Model.StoreLatitude?.ToString("F6") ?? "14.5995");
        const storeLng = @(Model.StoreLongitude?.ToString("F6") ?? "120.9842");
        const distance = calculateDistance(lat, lng, parseFloat(storeLat), parseFloat(storeLng));
        const radius = @Model.GeofenceRadiusKm;
        const isWithin = distance <= radius;
        
        // Add to location history for trail
        locationHistory.push({ 
            lat, 
            lng, 
            timestamp: new Date().toISOString(),
            isWithin: isWithin
        });
        
        // Keep only last 100 points
        if (locationHistory.length > 100) {
            locationHistory.shift();
        }
        
        // Update trail on map
        if (locationHistory.length > 1) {
            if (locationTrail) {
                map.removeLayer(locationTrail);
            }
            const trailPoints = locationHistory.map(point => [point.lat, point.lng]);
            const trailColor = isWithin ? '#3388ff' : '#ff3333';
            
            locationTrail = L.polyline(trailPoints, {
                color: trailColor,
                weight: 3,
                opacity: 0.6,
                smoothFactor: 1
            }).addTo(map);
        }

        // Update marker smoothly with animation
        if (renterMarker) {
            renterMarker.setLatLng([lat, lng], { 
                animate: true, 
                duration: 1.0, // 1 second smooth animation
                easeLinearity: 0.25
            });
            
            // Update marker icon color based on geofence status
            const markerIcon = L.icon({
                iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${isWithin ? 'blue' : 'red'}.png`,
                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                iconSize: [30, 48],
                iconAnchor: [15, 48],
                popupAnchor: [1, -40],
                shadowSize: [41, 41]
            });
            renterMarker.setIcon(markerIcon);
            
            // Update popup with current info
            renterMarker.setPopupContent(`
                <div style="text-align: center;">
                    <strong>Your Location</strong><br>
                    <code style="font-size: 0.9em;">${lat.toFixed(6)}, ${lng.toFixed(6)}</code><br>
                    <small style="color: #666;">
                        <i class="bi bi-circle-fill" style="color: #28a745; font-size: 0.6em;"></i> Live
                    </small>
                </div>
            `);
        }

        // Update UI
        document.getElementById('locationStatus').style.display = 'none';
        document.getElementById('locationInfo').style.display = 'block';
        
        const statusText = document.getElementById('statusText');
        const distanceText = document.getElementById('distanceText');
        const coordinatesText = document.getElementById('coordinatesText');
        const lastUpdateText = document.getElementById('lastUpdateText');
        const warningAlert = document.getElementById('warningAlert');
        const warningMessage = document.getElementById('warningMessage');

        distanceText.textContent = distance.toFixed(2) + ' km';
        coordinatesText.textContent = lat.toFixed(6) + ', ' + lng.toFixed(6);
        lastUpdateText.textContent = new Date().toLocaleTimeString();

        // Check if outside geofence
        const isWithin = distance <= radius;
        if (!isWithin) {
            statusText.textContent = '‚ö†Ô∏è Outside Geofence';
            statusText.style.color = 'var(--error)';
            distanceText.style.color = 'var(--error)';
            warningAlert.style.display = 'block';
            warningMessage.textContent = `You are ${(distance - radius).toFixed(2)} km outside the allowed radius. Please return to the geofence area.`;
        } else {
            statusText.textContent = '‚úì Within Geofence';
            statusText.style.color = 'var(--success)';
            distanceText.style.color = 'var(--sage-primary)';
            warningAlert.style.display = 'none';
        }
        
        // Always send location to server for live tracking (regardless of geofence status)
        if (sendToServer) {
            sendLocationToServer(lat, lng, distance, distance > radius);
        }
    }

    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Radius of the Earth in km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    let lastSentLocation = null;
    let isSendingLocation = false;
    
    function updateLocationSendingStatus(status) {
        const statusEl = document.getElementById('locationSendingStatus');
        if (statusEl) {
            statusEl.textContent = status;
        }
    }
    
    function sendLocationToServer(lat, lng, distance, isOutside) {
        // Prevent duplicate sends if already sending
        if (isSendingLocation) {
            addDebugLog('‚è≥ Location send already in progress, skipping...', 'info');
            return;
        }
        
        // Always send first location update (lastSentLocation is null)
        const isFirstUpdate = lastSentLocation === null;
        
        // Skip if location hasn't changed significantly (more than 10 meters) - but always send first update
        if (!isFirstUpdate && lastSentLocation) {
            const distanceChange = calculateDistance(
                lat, lng, 
                lastSentLocation.lat, lastSentLocation.lng
            ) * 1000; // Convert to meters
            
            if (distanceChange < 0.01) { // Less than 10 meters
                addDebugLog('üìç Location change too small (' + distanceChange.toFixed(2) + 'm), skipping send', 'info');
                return;
            }
        }
        
        isSendingLocation = true;
        addDebugLog('üì§ Sending location to server: ' + lat.toFixed(6) + ', ' + lng.toFixed(6) + ' (Booking ID: ' + @Model.Booking.BookingId + ', First: ' + isFirstUpdate + ')', 'info');
        updateLocationSendingStatus('Sending...');
        
        // Update send status UI
        const sendStatusEl = document.getElementById('sendStatus');
        if (sendStatusEl) {
            sendStatusEl.innerHTML = '<i class="bi bi-arrow-up-circle" style="color: var(--sage-primary);"></i> Sending location to owner...';
        }
        
        fetch('/api/location/track', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bookingId: @Model.Booking.BookingId,
                latitude: lat,
                longitude: lng
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                addDebugLog('‚úÖ Location sent successfully to server', 'success');
                addDebugLog('   Distance from store: ' + data.distanceKm + ' km, Within geofence: ' + data.isWithinGeofence, 'success');
                updateLocationSendingStatus('Last sent: ' + new Date().toLocaleTimeString());
                
                // Update last sent location
                lastSentLocation = { lat: lat, lng: lng, timestamp: Date.now() };
                
                // Update send status UI
                if (sendStatusEl) {
                    sendStatusEl.innerHTML = '<i class="bi bi-check-circle" style="color: var(--success);"></i> Location sent to owner successfully';
                    setTimeout(() => {
                        if (sendStatusEl) {
                            sendStatusEl.innerHTML = '<i class="bi bi-arrow-repeat" style="color: var(--neutral-400);"></i> Next update in 10 seconds...';
                        }
                    }, 2000);
                }
            } else {
                addDebugLog('‚ùå Error sending location: ' + data.error, 'error');
                updateLocationSendingStatus('Error: ' + data.error);
                if (sendStatusEl) {
                    sendStatusEl.innerHTML = '<i class="bi bi-exclamation-triangle" style="color: var(--error);"></i> Error sending location';
                }
            }
            isSendingLocation = false;
        })
        .catch(error => {
            addDebugLog('‚ùå Error sending location to server: ' + error.message, 'error');
            updateLocationSendingStatus('Error - Retrying...');
            isSendingLocation = false;
            
            // Update send status UI
            const sendStatusEl = document.getElementById('sendStatus');
            if (sendStatusEl) {
                sendStatusEl.innerHTML = '<i class="bi bi-exclamation-triangle" style="color: var(--error);"></i> Error: ' + error.message + ' (retrying...)';
            }
            
            // Retry after 5 seconds if failed
            setTimeout(() => {
                if (!isSendingLocation) {
                    addDebugLog('üîÑ Retrying location send...', 'info');
                    sendLocationToServer(lat, lng, distance, isOutside);
                }
            }, 5000);
        });
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        if (watchId) {
            navigator.geolocation.clearWatch(watchId);
        }
        if (updateInterval) {
            clearInterval(updateInterval);
        }
    });
</script>